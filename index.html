<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>اِسْتَمِعْ إِلى الصَّوْت</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cairo:wght@700&family=Noto+Naskh+Arabic:wght@700&display=swap');

        :root {
            --player1-bg: #4a90e2;
            --player2-bg: #e24a4a;
            --correct-color: #50e3c2;
            --incorrect-color: #d0021b;
            --neutral-bg: #f4f4f4;
            --dark-text: #333;
            --selected-color: #888;
            --bonus-yellow: #ffde59;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; user-select: none; }
        html { overflow: hidden; }
        body {
            font-family: 'Cairo', sans-serif;
            display: flex; justify-content: center; align-items: center;
            height: 100dvh; background-color: var(--neutral-bg); overflow: hidden; direction: ltr;
        }
        #loading-indicator {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(255, 255, 255, 0.95);
            display: flex; justify-content: center; align-items: center;
            font-size: 2rem; color: var(--dark-text);
            z-index: 200; opacity: 1; transition: opacity 0.5s ease-out;
        }
        #loading-indicator.hidden { opacity: 0; pointer-events: none; }
        #game-container { display: flex; width: 100%; height: 100%; position: relative; }
        #progress-bar { 
            position: absolute; top: 0; left: 0; width: 100%; 
            display: flex; gap: 0; justify-content: center; align-items: center; 
            height: 30px; 
            z-index: 51;
        }
        .progress-dot { 
            flex: 1; 
            height: 100%; 
            background-color: #ccc; 
            border-radius: 0; 
            transition: background-color 0.3s;
            border-left: 1px solid #f4f4f4; 
        }
        .progress-dot:first-child { border-left: none; }
        .progress-dot.correct { background-color: var(--correct-color); }
        .progress-dot.incorrect { background-color: var(--incorrect-color); }
        
        #game-header {
            position: absolute; top: 30px; 
            left: 0; width: 100%; padding: 15px; background: #fff;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1); text-align: center; z-index: 50; direction: rtl;
            opacity: 0; transform: translateY(-30px); transition: opacity 0.6s ease, transform 0.6s ease;
        }
        #game-header.visible { opacity: 1; transform: translateY(0); }
        #game-header h1 { font-family: 'Noto Naskh Arabic', serif; font-size: 2.8rem; margin: 0; color: var(--dark-text); }

        .player-section {
            flex: 1;
            padding: 160px 5px 120px 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            transition: background-color: 0.3s;
            height: 100%;
            overflow-y: auto;
            position: relative;
        }
        #player1-section { background-color: rgba(74, 144, 226, 0.1); }
        
        #center-controls {
            position: absolute; 
            bottom: 20px; 
            right: 20px; 
            left: auto; 
            transform: none; 
            display: flex; 
            flex-direction: row; 
            align-items: center; 
            gap: 10px; 
            z-index: 10;
            opacity: 0; transition: opacity 0.6s ease, transform 0.6s ease;
        }
        #center-controls.visible { opacity: 1; transform: none; }
        #round-timer-bar-container { position: absolute; bottom: 0; left: 0; width: 100%; height: 12px; background-color: #ccc; z-index: 51; display: none; }
        #round-timer-bar { width: 100%; height: 100%; background-color: var(--incorrect-color); transform: scaleX(1); transform-origin: left; }
        @keyframes deplete-linear { 0% { transform: scaleX(1); } 100% { transform: scaleX(0); } }

        #audio-button {
            position: relative; width: 80px; height: 80px; border-radius: 50%; background-color: white; cursor: pointer;
            display: flex; justify-content: center; align-items: center; transition: all 0.2s; box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            border: 5px solid #ccc; z-index: 12;
        }
        #audio-button .icon { width: 35px; height: 35px; fill: #333; z-index: 13; }
        #audio-button .icon.stop-icon { display: none; }
        #audio-button.waiting .play-icon { animation: pulse-wait 1.5s infinite ease-in-out; }
        @keyframes pulse-wait { 0% { opacity: 1; } 50% { opacity: 0.3; } 100% { opacity: 1; } }
        #audio-button:disabled { cursor: not-allowed; opacity: 0.5; }

        #audio-button::before,
        #audio-button::after {
            content: '';
            position: absolute;
            width: 100%; height: 100%;
            border-radius: 50%;
            background-color: transparent;
            border: 4px solid var(--player1-bg);
            opacity: 0;
            transform: scale(1);
            z-index: 11; 
        }
        #audio-button.playing-sound::before {
            animation: wave-pulse 1.5s ease-out infinite;
        }
        #audio-button.playing-sound::after {
            animation: wave-pulse 1.5s ease-out 0.5s infinite;
        }
        @keyframes wave-pulse {
            0% { transform: scale(1); opacity: 0.6; }
            100% { transform: scale(1.4); opacity: 0; }
        }


        #next-round-button {
            margin-top: 0; 
            width: 80px;
            height: 80px;
            border-radius: 50%;
            padding: 0;
            cursor: pointer; 
            border: 5px solid #ccc; 
            background-color: white; 
            box-shadow: 0 5px 15px rgba(0,0,0,0.1); 
            transition: all 0.2s; 
            z-index: 11; 
            display: flex; 
            justify-content: center;
            align-items: center;
        }
        #next-round-button:hover { transform: scale(1.05); }

        #next-round-button .icon {
            width: 35px; 
            height: 35px; 
            fill: #333; 
            z-index: 13;
        }

        #next-round-button:disabled { 
            cursor: not-allowed; 
            opacity: 0.5; 
        }
        
        .image-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 10px; width: 100%; 
            max-width: 840px; 
            margin: 0 auto;
            border: 5px solid transparent; border-radius: 20px; padding: 5px; transition: all 0.6s ease;
        }
        .image-grid.highlight { border-color: var(--player1-bg); box-shadow: 0 0 20px var(--player1-bg); }
        .image-grid.locked .image-container { pointer-events: none; opacity: 0.7; }

        .image-container {
            width: 100%; padding-top: 100%; position: relative; border: 5px solid transparent; border-radius: 15px; overflow: hidden;
            background-color: #e0e0e0; transition: transform 0.2s, border-color 0.2s, opacity 0.2s; cursor: pointer;
        }
        .image-grid.locked .image-container.selected { border-color: var(--selected-color); opacity: 1; transform: scale(0.95); }
        .image-container img { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; }
        .image-container.correct { border-color: var(--correct-color); opacity: 1; }
        .image-container.incorrect { border-color: var(--incorrect-color); opacity: 1; }

        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(255, 255, 255, 0.9);
            display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; direction: rtl;
            opacity: 0; pointer-events: none; transition: opacity 0.8s ease, background-color 0.8s ease;
        }
        #overlay.visible { opacity: 1; pointer-events: auto; }
        #overlay.transparent-bg { background-color: transparent; }

        .overlay-button {
            padding: 20px 40px; font-family: 'Noto Naskh Arabic', serif; font-size: 2.5rem; cursor: pointer; border: none; border-radius: 10px;
            background-color: var(--player1-bg); color: white; box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        #reset-icon { font-size: 5rem; cursor: pointer; display: none; }
        #countdown { font-size: 12rem; font-weight: bold; color: var(--dark-text); animation: zoom-fade 1s ease-in-out infinite; }

        #winner-display {
            font-family: 'Noto Naskh Arabic', serif; 
            font-size: 3.0rem; font-weight: bold; color: var(--dark-text);
            margin-bottom: 20px; display: none; text-align: center; animation: zoom-fade 1.5s ease-in-out infinite;
        }

        #player-select-prompt { display: none; flex-direction: column; align-items: center; text-align: center; }
        #player-select-text { font-family: 'Noto Naskh Arabic', serif; font-size: 3.5rem; font-weight: bold; color: var(--dark-text); margin-bottom: 20px; }
        #start-countdown-button { font-size: 6rem; cursor: pointer; background: none; border: none; padding: 10px; color: var(--dark-text); transition: transform 0.2s ease-out; animation: zoom-fade 1.5s ease-in-out infinite; }
        #start-countdown-button:hover { transform: scale(1.1); }

        @keyframes zoom-fade { 0% { transform: scale(0.8); opacity: 0.5; } 50% { transform: scale(1); opacity: 1; } 100% { transform: scale(0.8); opacity: 0.5; } }


        @media (max-width: 768px) {
            #progress-bar { height: 20px; }
            #game-header { top: 20px; }
            #center-controls { bottom: 20px; right: 20px; }
            #audio-button { width: 70px; height: 70px; }
            #next-round-button { width: 70px; height: 70px; }
            .player-section { padding: 140px 5px 110px 5px; } 
            .image-grid { gap: 5px; max-width: 100%; }
            #game-header h1 { font-size: 2.0rem; } 
            .progress-dot { border-radius: 0; }
            #winner-display { font-size: 2.2rem; }
            #player-select-text { font-size: 2.5rem; }
            #start-countdown-button { font-size: 5rem; }
        }
        @media (max-width: 480px) {
            #progress-bar { height: 15px; }
            #game-header { top: 15px; }
            .player-section { padding: 130px 5px 100px 5px; } 
            #center-controls { bottom: 10px; right: 10px; gap: 5px;}
            #audio-button { width: 60px; height: 60px; }
            #audio-button .icon { width: 30px; height: 30px; }
            #next-round-button { width: 60px; height: 60px; }
            #next-round-button .icon { width: 30px; height: 30px; }
            #game-header h1 { font-size: 1.8rem; } 
            .progress-dot { border-radius: 0; }
        }
    </style>
</head>
<body>
    <div id="loading-indicator">...يتم التحميل</div>

    <div id="game-container">
        
        <div id="progress-bar">
            <div class="progress-dot"></div>
            <div class="progress-dot"></div>
            <div class="progress-dot"></div>
            <div class="progress-dot"></div>
            <div class="progress-dot"></div>
            <div class="progress-dot"></div>
            <div class="progress-dot"></div>
            <div class="progress-dot"></div>
        </div>

        <div id="game-header">
            <h1>اِسْتَمِعْ إِلى الصَّوْت، وَاخْتَر الصّورَة المُناسِبَة</h1>
        </div>

        <div class="player-section" id="player1-section">
            <div class="image-grid" id="image-grid-1">
                <div class="image-container"></div>
                <div class="image-container"></div>
                <div class="image-container"></div>
                <div class="image-container"></div>
            </div>
        </div>

        <div id="center-controls">
            <button id="audio-button" disabled>
                <svg class="icon play-icon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"></path></svg>
                <svg class="icon stop-icon" viewBox="0 0 24 24"><path d="M6 6h12v12H6z"></path></svg>
            </button>

            <button id="next-round-button" disabled>
                <svg class="icon" viewBox="0 0 24 24"><path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"></path></svg>
            </button>
        </div>

        <div id="round-timer-bar-container">
            <div id="round-timer-bar"></div>
        </div>

        <div id="overlay">
            <div id="countdown" style="display: none;"></div>
            <div id="winner-display"></div>

            <div id="player-select-prompt">
                <div id="player-select-text">هَلْ أَنْتَ مُسْتَعِدّ؟</div>
                <button id="start-countdown-button">▶️</button>
            </div>
            <button class="overlay-button" id="start-button">اِبْدَأْ</button>
            <div id="reset-icon">&#128260;</div>
        </div>
    </div>

    <script>
        // DOM Elementlerini seçme
        const loadingIndicator = document.getElementById('loading-indicator');
        const startButton = document.getElementById('start-button');
        const overlay = document.getElementById('overlay');
        const countdownDisplay = document.getElementById('countdown');
        const resetButton = document.getElementById('reset-icon');
        const audioButton = document.getElementById('audio-button');
        const playIcon = audioButton.querySelector('.play-icon');
        const stopIcon = audioButton.querySelector('.stop-icon');

        const nextRoundButton = document.getElementById('next-round-button');

        const roundTimerBarContainer = document.getElementById('round-timer-bar-container');
        const roundTimerBar = document.getElementById('round-timer-bar');

        const gameHeader = document.getElementById('game-header');
        const centerControls = document.getElementById('center-controls');
        
        const allGrids = document.getElementById('image-grid-1'); 
        const grid1 = document.getElementById('image-grid-1');

        const allImageContainers = document.querySelectorAll('#image-grid-1 .image-container');
        const gameContainer = document.getElementById('game-container');
        const winnerDisplay = document.getElementById('winner-display');
        const playerSelectPrompt = document.getElementById('player-select-prompt');
        const startCountdownButton = document.getElementById('start-countdown-button');

        // Audio Ayarları
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const audioBuffers = {};
        let currentAudio = new Audio(); 

        const soundUrls = {
            // 'instruction' sesi kaldırıldı.
        };
        
        // Oyun Verisi
        const gameData = [
            { id: 1, image: "1.png", audio: "s1.mp3" },
            { id: 2, image: "2.png", audio: "s2.mp3" },
            { id: 3, image: "3.png", audio: "s3.mp3" },
            { id: 4, image: "4.png", audio: "s4.mp3" },
            { id: 5, image: "5.png", audio: "s5.mp3" },
            { id: 6, image: "6.png", audio: "s6.mp3" },
            { id: 7, image: "7.png", audio: "s7.mp3" },
            { id: 8, image: "8.png", audio: "s8.mp3" }
        ];

        // Oyun Durumu (State)
        let state = {
            currentRound: 0,
            totalRounds: 8, 
            questions: [],
            isAnswered: false,
            answers: { player1: null },
            answerTimestamps: { player1: null },
            roundTimer: null,
            audioInterval: null,
            isMatchOver: false,
            roundTimerStartTime: null,
            roundTimerRemaining: 0
        };

        // --- ÖN YÜKLEME FONKSİYONLARI ---

        // >>> YENİ FONKSİYON: loadGameAudio <<<
        // 'preloadAudio' içinden buraya taşındı.
        // Sadece 'Başla' butonuna tıklandıktan sonra çağrılacak.
        function loadGameAudio() {
            return new Promise((resolve) => {
                let loadedCount = 0;
                const totalAudio = gameData.length;
                if (totalAudio === 0) return resolve();
                
                const onAudioLoad = () => { 
                    loadedCount++; 
                    if (loadedCount === totalAudio) {
                        console.log("Tüm .wav oyun sesleri yüklendi.");
                        resolve(); 
                    }
                };

                console.log(".wav oyun sesleri yükleniyor...");
                gameData.forEach(item => {
                    const audio = new Audio();
                    audio.src = item.audio;
                    // Bir ses dosyası yüklenemese bile (404 vb) diğerlerinin yüklenmesini
                    // bitirmek için 'error' olayını da 'onAudioLoad'a bağla.
                    audio.addEventListener('canplaythrough', onAudioLoad, { once: true });
                    audio.addEventListener('error', (e) => {
                        console.warn(`.wav sesi ${item.audio} yüklenemedi, ama devam ediliyor.`, e);
                        onAudioLoad(); 
                    }, { once: true }); 
                });
            });
        }


        function preloadImages() {
            return new Promise((resolve) => {
                let loadedCount = 0;
                const totalImages = gameData.length;
                if (totalImages === 0) { resolve(); return; }
                gameData.forEach(item => {
                    const img = new Image();
                    img.src = item.image;
                    img.onload = img.onerror = () => { loadedCount++; if (loadedCount === totalImages) resolve(); };
                });
            });
        }

        async function loadAudio(key, url) {
            // 'file://' hatasını önlemek için AudioContext'in hazır olduğundan emin ol
            if (audioContext.state === 'suspended') {
                await audioContext.resume();
            }
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status} for ${url}`);
                }
                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                audioBuffers[key] = audioBuffer;
            } catch (error) {
                console.error(`Web Audio API sesi yüklenemedi ${key} (${url}):`, error);
            }
        }

        function playSound(key, onEndedCallback = null) {
            if (audioContext.state === 'suspended') {
                audioContext.resume(); 
            }

            if (!audioBuffers[key]) {
                console.warn(`Ses buffer'ı bulunamadı: ${key}`);
                if (onEndedCallback) onEndedCallback();
                return null;
            }

            if (audioContext.state !== 'running') {
                console.warn(`AudioContext çalışmıyor. Kullanıcı etkileşimi bekleniyor.`);
                 audioContext.resume().then(() => {
                    if (audioBuffers[key]) {
                         const sourceRetry = audioContext.createBufferSource();
                        sourceRetry.buffer = audioBuffers[key];
                        sourceRetry.connect(audioContext.destination);
                        if (onEndedCallback) sourceRetry.onended = onEndedCallback;
                        sourceRetry.start(0);
                        return sourceRetry;
                    }
                 }).catch(e => {
                    console.warn(`AudioContext başlatılamadı:`, e);
                    if (onEndedCallback) onEndedCallback();
                 });
                return null; 
            }
            
            const source = audioContext.createBufferSource();
            source.buffer = audioBuffers[key];
            source.connect(audioContext.destination);
            
            if (onEndedCallback) {
                source.onended = onEndedCallback;
            }
            source.start(0);
            return source;
        }

        function createTone(key, frequency, duration, type = 'sine') {
            return new Promise(async (resolve) => {
                if (audioContext.state === 'suspended') {
                    try {
                        await audioContext.resume();
                    } catch (e) {
                        console.warn(`AudioContext ${key} için devam ettirilemedi:`, e);
                        resolve(); 
                        return;
                    }
                }
                
                const sampleRate = audioContext.sampleRate;
                const frameCount = Math.floor(sampleRate * duration);
                const buffer = audioContext.createBuffer(1, frameCount, sampleRate);
                const data = buffer.getChannelData(0); 

                let angle = 0;
                const angleIncrement = (2 * Math.PI * frequency) / sampleRate;

                for (let i = 0; i < frameCount; i++) {
                    let sample;
                    
                    if (type === 'square') {
                         sample = Math.sin(angle) >= 0 ? 0.3 : -0.3; 
                    } else if (type === 'sawtooth') {
                        sample = (((angle / Math.PI) - 1) / 2) * 0.3;
                        if (angle > Math.PI) angle -= 2 * Math.PI;
                    } else {
                        sample = Math.sin(angle) * 0.5; 
                    }
                    
                    angle += angleIncrement;
                    if (angle > 2 * Math.PI) angle -= 2 * Math.PI;

                    const envelope = Math.pow(1.0 - (i / frameCount), 4); 
                    
                    data[i] = sample * envelope; 
                }
                
                audioBuffers[key] = buffer;
                resolve();
            });
        }


        // >>> DEĞİŞİKLİK: preloadAudio <<<
        // Bu fonksiyon 'runIntroAnimation'un donmasını engellemek için kasıtlı olarak boşaltıldı.
        // Tüm ses yüklemeleri artık 'showReadyPrompt' içinde, kullanıcı tıkladıktan *sonra* yapılıyor.
        function preloadAudio() {
            // createTone sesleri (efektler) 'showReadyPrompt'a taşındı.
            // gameData sesleri (.wav) 'loadGameAudio'ya (o da showReadyPrompt'a) taşındı.
            // 'soundUrls' listesi boş.
            // Bu fonksiyon artık sadece 'soundUrls' listesini yükler (o da boş).
            // Bu yüzden temelde hiçbir şey yapmıyor, bu da 'await'in hemen tamamlanacağı anlamına gelir.
            
            const promises = [];
            for (const [key, url] of Object.entries(soundUrls)) {
                promises.push(loadAudio(key, url));
            }
            return Promise.all(promises); // Boş bir listeyi veya 'soundUrls' listesini döndürür
        }

        // --- OYUN AKIŞI FONKSİYONLARI ---

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function startGame() {
            playerSelectPrompt.style.display = 'none';
            startMatch();
            toggleAudio();
        }

        // >>> DEĞİŞİKLİK: showReadyPrompt <<<
        // Artık 'loadGameAudio' (.wav) ve 'createTone' (efekt) fonksiyonlarını çağırıyor.
        // Yükleme sırasında 'loadingIndicator'ı tekrar gösteriyor.
        async function showReadyPrompt() {
            if (audioContext.state === 'suspended') {
                await audioContext.resume(); // 'await' kullan
            }
            
            // "Yükleniyor..." ekranını hızlıca göstermek için butonu gizle
            startButton.style.display = 'none';
            loadingIndicator.classList.remove('hidden'); // Yükleniyor'u tekrar göster
            loadingIndicator.textContent = "...Sesler yükleniyor..."; // Mesajı güncelle

            // >>> EKLENEN BÖLÜM: TÜM sesleri ilk tıklamada yükle
            try {
                console.log("Efekt sesleri (createTone) üretiliyor...");
                // 1. Efekt seslerini üret
                await Promise.all([
                    createTone('correct', 880, 0.3, 'sine'),
                    createTone('incorrect', 220, 0.5, 'sine'),
                    createTone('click', 1500, 0.05, 'sine')
                ]);
                console.log("Efekt sesleri üretildi.");

                // 2. .wav seslerini yükle (yeni fonksiyon)
                await loadGameAudio(); 

            } catch (e) {
                console.error("Sesler yüklenirken hata oluştu:", e);
            }
            // <<< EKLENEN BÖLÜM SONU

            loadingIndicator.classList.add('hidden'); // Yükleme bitti, gizle
            
            if (countdownDisplay) countdownDisplay.style.display = 'none';
            if (playerSelectPrompt) playerSelectPrompt.style.display = 'flex';
            if (overlay) overlay.classList.remove('transparent-bg');
        }


        function startCountdownAndGame() {
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            playerSelectPrompt.style.display = 'none';
            overlay.classList.remove('visible'); overlay.classList.remove('transparent-bg');
            startGame();
        }

        function startMatch() {
            state.currentRound = 0;
            state.isMatchOver = false;

            state.questions = shuffleArray([...gameData]).slice(0, state.totalRounds)
                .map(item => ({ ...item, duration: 30000 }));

            nextRound();
        }

        function nextRound() {
            if (state.isMatchOver || state.currentRound >= state.totalRounds) {
                if (!overlay.classList.contains('visible') && !state.isMatchOver) endMatch();
                return;
            }
            resetRound();

            const currentQuestion = state.questions[state.currentRound];
            const correctId = currentQuestion.id;

            // (Distractor logic)
            const conflictGroupA = [1];
            const conflictGroupB = [2, 3, 4];
            let bannedDistractorIds = []; 
            if (conflictGroupA.includes(correctId)) {
                bannedDistractorIds = conflictGroupB;
            } else if (conflictGroupB.includes(correctId)) {
                bannedDistractorIds = conflictGroupA;
            }
            const possibleDistractors = gameData.filter(item => {
                if (item.id === correctId) return false;
                if (bannedDistractorIds.includes(item.id)) return false;
                return true;
            });
            const shuffledDistractors = shuffleArray(possibleDistractors);
            const finalDistractors = shuffledDistractors.slice(0, 3);
            // (Distractor logic sonu)

            const options = shuffleArray([currentQuestion, ...finalDistractors]);

            allImageContainers.forEach((c, i) => {
                c.dataset.id = options[i].id;
                const img = document.createElement('img');
                img.src = options[i].image; img.alt = "خيار";
                c.appendChild(img);
            });
            
            audioButton.disabled = false;
            state.currentRound++;
        }

        function resetRound() {
            state.isAnswered = false;
            state.answers = { player1: null };
            state.answerTimestamps = { player1: null };
            state.roundTimerStartTime = null;
            state.roundTimerRemaining = 0;

            clearTimeout(state.roundTimer);
            stopAudioLoop(); 

            nextRoundButton.disabled = true;

            audioButton.classList.remove('round-active');

            roundTimerBarContainer.style.display = 'none';
            roundTimerBar.classList.remove('active');
            roundTimerBar.style.animation = 'none';
            roundTimerBar.style.animationPlayState = 'running';
            void roundTimerBar.offsetWidth;
            roundTimerBar.style.animation = null;

            grid1.classList.remove('locked');

            allImageContainers.forEach(container => {
                container.classList.remove('correct', 'incorrect', 'locked', 'selected');
                const img = container.querySelector('img');
                if (img) img.remove();
            });
        }

        // --- SES KONTROL FONKSİYONLARI ---

        function toggleAudio() {
            if (state.isMatchOver || state.isAnswered || state.currentRound > state.totalRounds || !state.questions[state.currentRound - 1]) return;

            if (!audioButton.classList.contains('round-active')) {
                nextRoundButton.disabled = true;
                
                audioButton.classList.add('round-active', 'playing-sound', 'waiting');

                const currentDuration = state.questions[state.currentRound - 1].duration;
                state.roundTimerStartTime = Date.now();
                state.roundTimerRemaining = currentDuration;

                roundTimerBarContainer.style.display = 'block';
                roundTimerBar.style.animation = `deplete-linear ${currentDuration / 1000}s linear forwards`;
                roundTimerBar.classList.add('active');

                state.roundTimer = setTimeout(handleTimeout, state.roundTimerRemaining);

                setTimeout(() => {
                    if (state.isMatchOver || !audioButton.classList.contains('round-active') || state.isAnswered) return;
                    audioButton.classList.remove('waiting');
                    startAudioLoop(true); 
                }, 2000);
            } else {
                if (audioButton.classList.contains('playing-sound')) {
                    stopAudioLoop(); 
                } else {
                    startAudioLoop(false); 
                }
            }
        }

        function startAudioLoop(isInitialCall) {
            if (state.isMatchOver || state.isAnswered || !audioButton.classList.contains('round-active') || state.currentRound > state.totalRounds || !state.questions[state.currentRound - 1]) return;

            if (!isInitialCall) {
                state.roundTimerStartTime = Date.now();
                state.roundTimer = setTimeout(handleTimeout, state.roundTimerRemaining);
                roundTimerBar.style.animationPlayState = 'running';
            }

            audioButton.classList.add('playing-sound');
            playIcon.style.display = 'none';
            stopIcon.style.display = 'block';

            const audioSrc = state.questions[state.currentRound - 1].audio;
            currentAudio.src = audioSrc;

            currentAudio.onended = () => {
                if (state.isMatchOver || state.isAnswered || !audioButton.classList.contains('playing-sound')) return;
                audioButton.classList.add('waiting');
                playIcon.style.display = 'block';
                stopIcon.style.display = 'none';
                state.audioInterval = setTimeout(() => {
                    audioButton.classList.remove('waiting');
                    if (audioButton.classList.contains('playing-sound') && !state.isAnswered && !state.isMatchOver) {
                        playIcon.style.display = 'none';
                        stopIcon.style.display = 'block';
                        currentAudio.play();
                    }
                }, 5000);
            };

            currentAudio.play().catch(() => {});
        }

        function stopAudioLoop() {
            clearTimeout(state.audioInterval);
            
            if (!currentAudio.paused) {
                currentAudio.pause();
            }
            currentAudio.currentTime = 0;
            currentAudio.onended = null;

            if (audioButton.classList.contains('round-active') && !state.isAnswered) {
                clearTimeout(state.roundTimer);
                if (state.roundTimerStartTime) {
                    const elapsedTime = Date.now() - state.roundTimerStartTime;
                    state.roundTimerRemaining -= elapsedTime;
                }
                roundTimerBar.style.animationPlayState = 'paused';
            }

            audioButton.classList.remove('playing-sound', 'waiting');
            playIcon.style.display = 'block';
            stopIcon.style.display = 'none';
        }

        // --- CEVAPLAMA VE SONUÇ FONKSİYONLARI ---

        document.querySelectorAll('#image-grid-1 .image-container').forEach(container => {
            container.addEventListener('click', handleAnswer);
        });

        function handleAnswer(e) {
            const playerSection = e.currentTarget.closest('.player-section');
            
            if (playerSection.id !== 'player1-section') return;
            
            const player = 'player1';

            if (!audioButton.classList.contains('round-active') ||
                state.answers[player] !== null ||
                state.isMatchOver ||
                state.isAnswered) return;

            playSound('click'); // Web Audio API tıklama sesi (üretilen)

            const selectedContainer = e.currentTarget;
            const selectedId = parseInt(selectedContainer.dataset.id);

            state.answers[player] = selectedId;
            state.answerTimestamps[player] = Date.now();

            playerSection.querySelector('.image-grid').classList.add('locked');
            selectedContainer.classList.add('selected');

            state.isAnswered = true;
            clearTimeout(state.roundTimer);
            roundTimerBar.style.animationPlayState = 'paused';
            stopAudioLoop(); 
            processAnswers();
        }

        function processAnswers() {
            stopAudioLoop(); 
            clearTimeout(state.roundTimer);
            if (state.isMatchOver || !state.questions[state.currentRound - 1]) return;

            const currentDot = document.querySelectorAll('.progress-dot')[state.currentRound - 1];

            const correctId = state.questions[state.currentRound - 1].id;
            const p1Answer = state.answers.player1;
            const p1Correct = (p1Answer === correctId);

            const p1Choice = (p1Answer !== null) ? grid1.querySelector(`.image-container[data-id='${p1Answer}']`) : null;
            
            const allCorrectContainers = document.querySelectorAll(`#image-grid-1 .image-container[data-id='${correctId}']`);

            allCorrectContainers.forEach(c => { c.classList.remove('selected'); c.classList.add('correct'); });

            let anyCorrect = false;

            if (p1Correct) {
                anyCorrect = true;
                if (currentDot) currentDot.classList.add('correct'); 
            } else { 
                if (p1Answer !== null && !p1Correct) {
                    if (p1Choice) { p1Choice.classList.remove('selected'); p1Choice.classList.add('incorrect'); }
                }
                if (currentDot) currentDot.classList.add('incorrect'); 
            }

            if (anyCorrect) playSound('correct'); else playSound('incorrect');

            grid1.classList.add('locked');

            setTimeout(() => {
                if (state.currentRound >= state.totalRounds && !state.isMatchOver) {
                    endMatch();
                } else if (!state.isMatchOver) {
                    nextRoundButton.disabled = false;
                }
            }, 1000);
        }

        function handleTimeout() {
            if (state.isAnswered || state.isMatchOver) return;
            state.isAnswered = true;
            roundTimerBar.style.animationPlayState = 'paused';
            stopAudioLoop(); 
            processAnswers();
        }

        function endMatch() {
            if (state.isMatchOver) return;
            state.isMatchOver = true;
            stopAudioLoop(); clearTimeout(state.roundTimer);

            overlay.classList.add('visible');
            overlay.classList.remove('transparent-bg');
            countdownDisplay.style.display = 'none';
            resetButton.style.display = 'block';

            audioButton.disabled = true;
            nextRoundButton.disabled = true;
            resetRound();
        }

        function resetForNewGame() {
            resetButton.style.display = 'none';
            playerSelectPrompt.style.display = 'flex';
            winnerDisplay.style.display = 'none';
            
            document.querySelectorAll('.progress-dot').forEach(dot => {
                dot.classList.remove('correct', 'incorrect');
            });
        }

        // --- OYUNU BAŞLATMA ---

        async function runIntroAnimation() {
             if (audioContext.state === 'suspended') {
                 audioContext.resume().catch(() => {});
             }

            // 'loadingIndicator' hatasını önlemek için bekle
            // 'preloadAudio' artık 'createTone' VEYA '.wav' yüklemesi içermediği için donmayacak.
            // Sadece resimler yüklenecek.
            await Promise.all([preloadImages(), preloadAudio()]);
            
            loadingIndicator.classList.add('hidden');
            overlay.classList.add('visible', 'transparent-bg');

            setTimeout(() => { gameHeader.classList.add('visible'); }, 600);
            
            setTimeout(() => { allGrids.classList.add('highlight'); }, 1200);
            setTimeout(() => { centerControls.classList.add('visible'); }, 1800);
            setTimeout(() => { allGrids.classList.remove('highlight'); }, 2400);
        }

        // Event Listeners
        // 'startButton' tıklandığında artık 'showReadyPrompt' çağrılıyor
        startButton.addEventListener('click', showReadyPrompt);
        startCountdownButton.addEventListener('click', startCountdownAndGame);
        resetButton.addEventListener('click', resetForNewGame);
        audioButton.addEventListener('click', toggleAudio);

        document.querySelectorAll('#image-grid-1 .image-container').forEach(container => {
            container.addEventListener('click', handleAnswer);
        });

        nextRoundButton.addEventListener('click', () => {
            if (state.isMatchOver) return;
            nextRoundButton.disabled = true;
            nextRound();
            if (!state.isMatchOver && state.currentRound <= state.totalRounds) toggleAudio();
        });

        runIntroAnimation();
    </script>
</body>
</html>